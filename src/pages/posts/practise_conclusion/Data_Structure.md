---
title: "数据结构"
date: "2024-07-19"

layout: ../../../layouts/PostLayout.astro
description: "在这篇文章中可以对数据结构的学习更加深入了解"
---
# 什么是数据结构?

数据结构是用于存储和组织数据的存储。它是一种在计算机上排列数据的方式，以便可以有效地访问和更新数据。

## 种类：

![Alt text](/practise_conclusion/Interview_questions/分类.png)

# 复杂度

## 时间复杂度

### 时间复杂度分析

- 只关注循环执行次数最多的一段代码
- 总复杂度=最高阶项的复杂度
- 嵌套代码的复杂度=嵌套内外代码复杂度的乘积

推导大 O 阶:

1. 用常数 1 取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中,只保留最高阶项。
3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。

eg.

假设每行代码执行时间为 t
![Alt text](/practise_conclusion/Interview_questions/时间复杂度示例1.png)
所以 T(n)=100t+nt+n²t=(n²+n+100)t

由 2 得，时间复杂度为 O(n²)

![Alt text](/practise_conclusion/Interview_questions/时间复杂度.png)

> 时间复杂度 O(logn)一般是怎么出现的？

eg.

![Alt text](/practise_conclusion/Interview_questions/时间复杂度示例二.png)

在这个循环里面每循环一次 i 就\*2，所以会一直变为 2、2²、……直到循环结束。

所以 2 的 x 次方=n，想知道执行了多少次就得知道 x 为多少。

即 x=log2n(这里的 2 为底数，n 为对数)

但无论底数是多少，都会把对数样式的时间复杂度统一记为 logn

则这里的时间复杂度也是 O(logn)

## 空间复杂度

空间复杂度计算的是额外开辟的变量的个数

函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。

![Alt text](/practise_conclusion/Interview_questions/空间复杂度.png)

```python
# O(1)
def f1(n):
    j = 0
    for i in range(n):
        j += 1
    return j

# O(n)
def f2(n):
    a = []
    for i in range(n):
        a.append(i)
    return a
```

在第一个函数中，所需开辟的内存空间并不会随着 n 的变化而变化，即此算法空间复杂度为一个常量，所以表示为 O(1)。在第二个函数中，随着 n 的增大，开辟的内存大小呈线性增长，这样的算法空间复杂度为 O(n)。在递归的时候，会出现空间复杂度为 logn 的情况，比较特殊。

## 如何获取链表中的每个值？

先创建一个临时指针 temp 并把头节点的地址分配给它。然后它在循环里面逐级遍历，遍历链表直到 temp 指到地址为 NULL 的节点为止。

eg.
![Alt text](/practise_conclusion/Interview_questions/获取链表值.png)

# 链表

## 赋值

> 链表中的赋值操作实际上是将一个变量**指向**某个节点对象，**而不是**创建一个新的节点对象。当我们将一个节点赋值给头结点或尾节点时，实际上是让头结点或尾节点指向同一个节点对象。

在链表中，头结点和尾节点是用来跟踪链表的起始和结束位置的指针。通过将头结点和尾节点指向同一个节点对象，我们确保链表中只有一个节点，并且该节点既是头结点又是尾节点。这样做有助于在链表末尾执行插入操作时保持链表的一致性。

## 单链表头插法

链表中的赋值操作实际上是将一个变量指向某个节点对象，而不是创建一个新的节点对象。当我们将一个节点赋值给头结点或尾节点时，实际上是让头结点或尾节点指向同一个节点对象。

在 JavaScript 中，对象、数组和函数都是通过引用传递的。当我们将一个对象赋值给另一个变量时，实际上是将引用复制给了新的变量，而不是创建了一个新的对象。因此，当我们修改其中一个变量所引用的对象时，另一个变量也会反映这个变化。

在链表中，头结点和尾节点是用来跟踪链表的起始和结束位置的指针。通过将头结点和尾节点指向同一个节点对象，我们确保链表中只有一个节点，并且该节点既是头结点又是尾节点。这样做有助于在链表末尾执行插入操作时保持链表的一致性。

## 单链表头插法

1. 创建节点
2. 使新节点指向 head
3. 使 head 指向新节点
   ![Alt text](/practise_conclusion/Interview_questions/头插法.png)

## 单链表删除

先把后一节点变为头节点再删除头结点

## 如何返回链表

在 JavaScript 中的链表表现形式，链表中的每一个单元被视为一个独立的节点。每个节点由两个部分组成：一个是存储数据的字段（在这个例子中是 val），另一个则是指向下一个节点的链接字段（在这个例子中是 next）。
所以当我们说 "返回链表" 的时候，我们实际上在说 "返回链表的首节点"。因为我们只需要知道首节点，我们就可以通过 next 属性访问其他所有的节点。
在 return nodes[0]; 这一行中，nodes[0] 就是我们新链表的首节点。一旦你获取了这个节点，你就可以通过 next 属性访问链表中的其他所有节点。
对于链表，我们通常只需要知道其头部元素，然后通过其内部指针（这里是 next 属性）就可以访问链表中的所有元素。因此，我们说返回链表其实就是返回链表的第一个节点。
